# Patch to add whiptcl.so to all target, fix TCL result string, use -fPIC for snackmodule and fix linuxdoc tutorial
diff -urNad newt-0.52.18-orig/Makefile.in newt-0.52.18/Makefile.in
--- newt-0.52.18-orig/Makefile.in	2014-10-23 11:34:37.000000000 +0300
+++ newt-0.52.18/Makefile.in	2016-10-31 14:59:57.000000000 +0200
@@ -65,7 +65,7 @@
 TARGET=depend $(PROGS)
 endif
 
-all:	$(TARGET) _snack.$(SOEXT)
+all:	$(TARGET) _snack.$(SOEXT) whiptcl.$(SOEXT)
 
 test:	test.o $(LIBNEWT)
 	$(CC) -g -o test test.o $(LIBNEWT) $(LDFLAGS) $(LIBS)
@@ -96,9 +96,9 @@
 		PLDFLAGS=`$$pyconfig --ldflags`; \
 		PLFLAGS=`$$pyconfig --libs`; \
 		echo $(CC) $(SHCFLAGS) $(CPPFLAGS) $$PIFLAGS $$PCFLAGS -c -o $$ver/snack.o snack.c; \
-		$(CC) $(SHCFLAGS) $(CPPFLAGS) $$PIFLAGS $$PCFLAGS -c -o $$ver/snack.o snack.c; \
+		$(CC) $(SHCFLAGS) $(CPPFLAGS) $$PIFLAGS $$PCFLAGS -fPIC -c -o $$ver/snack.o snack.c; \
 		echo $(CC) --shared $$PLDFLAGS $$PLFLAGS $(LDFLAGS) -o $$ver/_snack.$(SOEXT) $$ver/snack.o -L.  -lnewt $(LIBS); \
-		$(CC) --shared $$PLDFLAGS $$PLFLAGS $(LDFLAGS) -o $$ver/_snack.$(SOEXT) $$ver/snack.o -L.  -lnewt $(LIBS); \
+		$(CC) --shared -fPIC $$PLDFLAGS $$PLFLAGS $(LDFLAGS) -o $$ver/_snack.$(SOEXT) $$ver/snack.o -L.  -lnewt $(LIBS); \
 	done || :
 	touch $@
 
diff -urNad newt-0.52.18-orig/tutorial.sgml newt-0.52.18/tutorial.sgml
--- newt-0.52.18-orig/tutorial.sgml	2014-10-23 11:34:37.000000000 +0300
+++ newt-0.52.18/tutorial.sgml	2016-10-31 14:58:28.000000000 +0200
@@ -1,124 +1,116 @@
-<!DOCTYPE Article PUBLIC "-//Davenport//DTD DocBook V3.0//EN">
+<!doctype linuxdoc system>
 
 <article>
 
-<artheader>
-<title>Writing Programs Using <literal remap="tt">newt</literal></title>
+<titlepag>
+<title>Writing Programs Using <tt>newt</tt></title>
 <author> 
-<firstname>Erik Troan, &lt;ewt@redhat.com&gt;</firstname>
+<name>Erik Troan, &lt;ewt@redhat.com&gt;</name>
 </author>
 
-<pubdate>v0.31, 2003-Jan-06</pubdate>
+<date>v0.31, 2003-Jan-06</date>
 
 <abstract>
-
-<para>
-The <literal remap="tt">newt</literal> windowing system is a terminal-based window and widget
+The <tt>newt</tt> windowing system is a terminal-based window and widget
 library designed for writing applications with a simple, but user-friendly,
-interface. While <literal remap="tt">newt</literal> is not intended to provide the rich feature
+interface. While <tt>newt</tt> is not intended to provide the rich feature
 set advanced applications may require, it has proven to be flexible enough
 for a wide range of applications (most notably, Red Hat's installation
-process). This tutorial explains the design philosophy behind <literal remap="tt">newt</literal> and
-how to use <literal remap="tt">newt</literal> from your programs.
-</para>
-
+process). This tutorial explains the design philosophy behind <tt>newt</tt> and
+how to use <tt>newt</tt> from your programs.
 </abstract>
-</artheader>
-
+</titlepag>
 
 
-<sect1><title>Introduction</title>
+<sect><heading>Introduction</heading>
 
-<para>
-<literal remap="tt">Newt</literal> has a definite design philosophy behind it, and knowing that design
-makes it significantly easier to craft robust <literal remap="tt">newt</literal> applications. This
-tutorial documents <literal remap="tt">newt</literal> 0.30 --- older versions of <literal remap="tt">newt</literal> had
+<p>
+<tt>Newt</tt> has a definite design philosophy behind it, and knowing that design
+makes it significantly easier to craft robust <tt>newt</tt> applications. This
+tutorial documents <tt>newt</tt> 0.30 --- older versions of <tt>newt</tt> had
 annoying inconsistencies in it (which writing this tutorial pointed out),
 which were removed while this tutorial was written. The latest version of
-<literal remap="tt">newt</literal> is always available from Red Hat.</para>
+<tt>newt</tt> is always available from Red Hat.</p>
 
-<sect2><title>Background</title>
+<sect1><heading>Background</heading>
 
-<para>
-<literal remap="tt">Newt</literal> was originally designed for use in the install code for
+<p>
+<tt>Newt</tt> was originally designed for use in the install code for
 Red Hat Linux. As this install code runs in an environment with limited
-resources (most importantly limited filesystem space), <literal remap="tt">newt</literal>'s size
+resources (most importantly limited filesystem space), <tt>newt</tt>'s size
 was immediately an issue. To help minimize its size, the following design
 decisions were made early in its implementation:
-</para>
-
-<itemizedlist>
-<listitem>
 
-<para>
- <literal remap="tt">newt</literal> does not use an event-driven architecture.
-</para>
-</listitem>
-<listitem>
-<para>
- <literal remap="tt">newt</literal> is written in C, not C++. While there has been interest
-in constructing C++ wrapper classes around the <literal remap="tt">newt</literal> API, nothing has
-yet come of those ideas.</para>
-</listitem>
-<listitem>
-
-<para>
+<itemize>
+<item>
+<p>
+ <tt>newt</tt> does not use an event-driven architecture.
+</p>
+</item>
+<item>
+<p>
+ <tt>newt</tt> is written in C, not C++. While there has been interest
+in constructing C++ wrapper classes around the <tt>newt</tt> API, nothing has
+yet come of those ideas.</p>
+</item>
+<item>
+<p>
  Windows must be created and destroyed as a stack (in other words, all
-<literal remap="tt">newt</literal> windows behave as modal dialogs). This is probably
-the greatest functionality restriction of <literal remap="tt">newt</literal>.</para>
-</listitem>
-<listitem>
-<para>
- The tty keyboard is the only supported input device.</para>
-</listitem>
-<listitem>
-
-<para>
+<tt>newt</tt> windows behave as modal dialogs). This is probably
+the greatest functionality restriction of <tt>newt</tt>.</p>
+</item>
+<item>
+<p>
+ The tty keyboard is the only supported input device.</p>
+</item>
+<item>
+<p>
  Many behaviours, such as widget traversal order, are difficult
 or impossible to change.
-</para>
-</listitem>
-</itemizedlist>
+</p>
+</item>
+</itemize>
+</p>
 
-<para>
-While <literal remap="tt">newt</literal> provides a complete API, it does not handle the low-level
-screen drawing itself. Instead, <literal remap="tt">newt</literal> is layered on top of the screen
+<p>
+While <tt>newt</tt> provides a complete API, it does not handle the low-level
+screen drawing itself. Instead, <tt>newt</tt> is layered on top of the screen
 management capabilities of John E. Davis's 
-<ulink url="ftp://space.mit.edu/pub/davis/slang/">S-Lang</ulink> library.</para></sect2>
+<url url="ftp://space.mit.edu/pub/davis/slang/" name="S-Lang"> library.</p>
+</sect1>
 
 
-<sect2><title>Designing <literal remap="tt">newt</literal> applications</title>
-<para>
-As <literal remap="tt">newt</literal> is not event driven and forces modal windows (forcing window
+<sect><heading>Designing <tt>newt</tt> applications</heading>
+<p>
+As <tt>newt</tt> is not event driven and forces modal windows (forcing window
 order to behave like a stack), newt applications tend to look quite like
 other text-mode programs. It is quite straightforward to convert a command
-line program which uses simple user prompts into a <literal remap="tt">newt</literal> application.
+line program which uses simple user prompts into a <tt>newt</tt> application.
 Some of the programs run as part of the Red Hat installation process
-(such as <literal remap="tt">Xconfigurator</literal> and <literal remap="tt">mouseconfig</literal>) were originally written
+(such as <tt>Xconfigurator</tt> and <tt>mouseconfig</tt>) were originally written
 as simple terminal mode programs which used line-oriented menus to get
-input from the user and were later converted into <literal remap="tt">newt</literal> applications
+input from the user and were later converted into <tt>newt</tt> applications
 (through a process affectionately known as newtering). Such a conversion
 does not require changes to the control flow of most applications.
 
-Programming <literal remap="tt">newt</literal> is dramatically different from writing programs for
-most other windowing systems as <literal remap="tt">newt</literal>'s API is not event driven. This
-means that <literal remap="tt">newt</literal> applications look dramatically different from programs
-written for event-driven architectures such as Motif, <literal remap="tt">gtk</literal>, or even
+Programming <tt>newt</tt> is dramatically different from writing programs for
+most other windowing systems as <tt>newt</tt>'s API is not event driven. This
+means that <tt>newt</tt> applications look dramatically different from programs
+written for event-driven architectures such as Motif, <tt>gtk</tt>, or even
 Borland's old TurboVision libraries.
 
-When you're designing your <literal remap="tt">newt</literal> program, keep this differentiation
+When you're designing your <tt>newt</tt> program, keep this differentiation
 in mind. As long as you plan your application to call a function to
 get input and then continue (rather then having your program called
 when input is ready), programming with the newt libraries should be
-simple.</para></sect2>
-
+simple.</p>
 
-<sect2><title>Components</title>
+<sect1><heading>Components</heading>
 
-<para>
-Displayable items in <literal remap="tt">newt</literal> are known as <emphasis remap="bf">components</emphasis>, which are
+<p>
+Displayable items in <tt>newt</tt> are known as <em>components</em>, which are
 analogous to the widgets provided by most Unix widget sets. There are
-two main types of components in <literal remap="tt">newt</literal>, forms and everything else.
+two main types of components in <tt>newt</tt>, forms and everything else.
 Forms logically group components into functional sets. When an application
 is ready to get input from a user, it ``runs a form'', which makes the
 form active and lets the user enter information into the components the
@@ -127,258 +119,229 @@
 of how the user tabs between components on the form, scroll regions of the
 screen, and control background colors for portions of windows.
 
-Every component is of type <literal remap="tt">newtComponent</literal>, which is an opaque type. It's
+Every component is of type <tt>newtComponent</tt>, which is an opaque type. It's
 guaranteed to be a pointer though, which lets applications move it through
-void pointers if the need arises. Variables of type <literal remap="tt">newtComponent</literal> should
-never be directly manipulated -- they should only be passed to <literal remap="tt">newt</literal>
-functions. As <literal remap="tt">newtComponent</literal> variables are pointers, remember that
-they are always passed by value -- if you pass a <literal remap="tt">newtComponent</literal> to
+void pointers if the need arises. Variables of type <tt>newtComponent</tt> should
+never be directly manipulated -- they should only be passed to <tt>newt</tt>
+functions. As <tt>newtComponent</tt> variables are pointers, remember that
+they are always passed by value -- if you pass a <tt>newtComponent</tt> to
 a function which manipulates it, that component is manipulated everywhere,
 not just inside of that function (which is nearly always the behaviour
-you want).</para></sect2>
-
+you want).</p></sect1>
 
-<sect2><title>Conventions</title>
+<sect1><heading>Conventions</heading>
 
-<para>
-<literal remap="tt">Newt</literal> uses a number of conventions to make it easier for programmers
+<p>
+<tt>Newt</tt> uses a number of conventions to make it easier for programmers
 to use. 
 
-
-<itemizedlist>
-<listitem>
-
-<para>
+<itemize>
+<item>
+<p>
  All functions which manipulate data structures take the data
 structure being modified as their first parameter. For example, all
-of the functions which manipulate forms expect the <literal remap="tt">newtComponent</literal>
-for that form to be the first parameter.</para></listitem>
-<listitem>
-
-<para>
- As <literal remap="tt">newt</literal> is loosely typed (forcing all of the components into
+of the functions which manipulate forms expect the <tt>newtComponent</tt>
+for that form to be the first parameter.</p></item>
+<item>
+<p>
+ As <tt>newt</tt> is loosely typed (forcing all of the components into
 a single variable makes coding easier, but nullifies the value of type
-checking), <literal remap="tt">newt</literal> functions include the name of the type they are
-manipulating. An example of this is <literal remap="tt">newtFormAddComponent()</literal>, which
+checking), <tt>newt</tt> functions include the name of the type they are
+manipulating. An example of this is <tt>newtFormAddComponent()</tt>, which
 adds a component to a form. Note that the first parameter to this function
-is a form, as the name would suggest.</para></listitem>
-<listitem>
-
-<para>
+is a form, as the name would suggest.</p></item>
+<item>
+<p>
  When screen coordinates are passed into a function, the 
 x location precedes the y location. To help keep this clear,
 we'll use the words ``left'' and ``top'' to describe those indicators (with
-left corresponding to the x position).</para></listitem>
-<listitem>
-
-<para>
+left corresponding to the x position).</p></item>
+<item>
+<p>
  When box sizes are passed, the horizontal width precedes the vertical
-width.</para></listitem>
-<listitem>
-
-<para>
+width.</p></item>
+<item>
+<p>
  When both a screen location and a box size are being passed, the
-screen location precedes the box size.</para></listitem>
-<listitem>
-
-<para>
+screen location precedes the box size.</p></item>
+<item>
+<p>
  When any component other then a form is created, the first two
-parameters are always the (left, right) location.</para></listitem>
-<listitem>
-
-<para>
+parameters are always the (left, right) location.</p></item>
+<item>
+<p>
  Many functions take a set of flags as the final parameter. These
-flags may be logically ORed together to pass more then one flag at a time.</para></listitem>
-<listitem>
-
-<para>
- <literal remap="tt">Newt</literal> uses <emphasis remap="bf">callback</emphasis> functions to convey certain events to
+flags may be logically ORed together to pass more then one flag at a time.</p></item>
+<item>
+<p>
+<tt>Newt</tt> uses <em>callback</em> functions to convey certain events to
 the application. While callbacks differ slightly in their parameters, most
 of them allow the application to specify an arbitrary argument to be passed
 to the callback when the callback is invoked. This argument is always a 
-<literal remap="tt">void *</literal>, which allows the application great flexibility.
-</para>
-</listitem>
-</itemizedlist>
-</para></sect2></sect1>
-
-
+<tt>void *</tt>, which allows the application great flexibility.
+</p>
+</item>
+</itemize>
+</p>
+</sect1>
+</sect>
 
-<sect1><title>Basic <literal remap="tt">Newt</literal> Functions</title>
 
-<para>
-While most <literal remap="tt">newt</literal> functions are concerned with widgets or groups
-of widgets (called grids and forms), some parts of the <literal remap="tt">newt</literal> API
-deal with more global issues, such as initializing <literal remap="tt">newt</literal> or writing
-to the root window.</para>
+<sect><heading>Basic <tt>Newt</tt> Functions</heading>
 
+<p>
+While most <tt>newt</tt> functions are concerned with widgets or groups
+of widgets (called grids and forms), some parts of the <tt>newt</tt> API
+deal with more global issues, such as initializing <tt>newt</tt> or writing
+to the root window.</p>
 
-<sect2><title>Starting and Ending <literal remap="tt">newt</literal> Services</title>
+<sect1><heading>Starting and Ending <tt>newt</tt> Services</heading>
 
-<para>
-There are three functions which nearly every <literal remap="tt">newt</literal> application use. The
+<p>
+There are three functions which nearly every <tt>newt</tt> application use. The
 first two are used to initialize the system.
 
-
-<screen>
+<code>
 int newtInit(void);
 void newtCls(void);
-</screen>
-
+</code>
 
-<literal remap="tt">newtInit()</literal> should be the first function called by every <literal remap="tt">newt</literal>
+<tt>newtInit()</tt> should be the first function called by every <tt>newt</tt>
 program. It initializes internal data structures and places the terminal
-in raw mode. Most applications invoke <literal remap="tt">newtCls()</literal> immediately after
-<literal remap="tt">newtInit()</literal>, which causes the screen to be cleared. It's not
-necessary to call <literal remap="tt">newtCls()</literal> to use any of <literal remap="tt">newt</literal>'s features, but
-doing so will normally give a much neater appearance.
-
-When a <literal remap="tt">newt</literal> program is ready to exit, it should call <literal remap="tt">newtFinished()</literal>.
+in raw mode. Most applications invoke <tt>newtCls()</tt> immediately after
+<tt>newtInit()</tt>, which causes the screen to be cleared. It's not
+necessary to call <tt>newtCls()</tt> to use any of <tt>newt</tt>'s features, but
+doing so will normally give a much neater appearance.</p>
 
+<p>When a <tt>newt</tt> program is ready to exit, it should call <tt>newtFinished()</tt>.
 
-<screen>
+<code>
 int newtFinished(void);
-</screen>
-
+</code>
 
-<literal remap="tt">newtFinished()</literal> restores the terminal to its appearance when
-<literal remap="tt">newtInit()</literal> was called (if possible -- on some terminals the cursor will
+<tt>newtFinished()</tt> restores the terminal to its appearance when
+<tt>newtInit()</tt> was called (if possible -- on some terminals the cursor will
 be moved to the bottom, but it won't be possible to remember the original
 terminal contents) and places the terminal in its original input state.
 If this function isn't called, the terminal will probably need to be
-reset with the <literal remap="tt">reset</literal> command before it can be used easily.</para></sect2>
-
+reset with the <tt>reset</tt> command before it can be used easily.</p>
+</sect1>
 
-<sect2><title>Handling Keyboard Input</title>
+<sect1><heading>Handling Keyboard Input</heading>
 
-<para>
-Normally, <literal remap="tt">newt</literal> programs don't read input directly from the
-user. Instead, they let <literal remap="tt">newt</literal> read the input and hand it to the
-program in a semi-digested form. <literal remap="tt">Newt</literal> does provide a couple of simple
+<p>
+Normally, <tt>newt</tt> programs don't read input directly from the
+user. Instead, they let <tt>newt</tt> read the input and hand it to the
+program in a semi-digested form. <tt>Newt</tt> does provide a couple of simple
 functions which give programs (a bit of) control over the terminal.
 
-
-<screen>
+<code>
 void newtWaitForKey(void);
 void newtClearKeyBuffer(void);
-</screen></para>
-
-
+</code>
 
-<para>
-The first of these, <literal remap="tt">newtWaitForKey()</literal>, doesn't return until a key
+The first of these, <tt>newtWaitForKey()</tt>, doesn't return until a key
 has been pressed. The keystroke is then ignored. If a key is already in
-the terminal's buffer, <literal remap="tt">newtWaitForKey()</literal> discards a keystroke and
+the terminal's buffer, <tt>newtWaitForKey()</tt> discards a keystroke and
 returns immediately.
 
-<literal remap="tt">newtClearKeyBuffer()</literal> discards the contents of the terminal's input
-buffer without waiting for additional input.</para></sect2> 
-
+<tt>newtClearKeyBuffer()</tt> discards the contents of the terminal's input
+buffer without waiting for additional input.</p></sect1> 
 
-<sect2><title>Drawing on the Root Window</title>
+<sect1><heading>Drawing on the Root Window</heading>
 
-<para>
+<p>
 The background of the terminal's display (the part without any windows 
-covering it) is known as the <emphasis remap="bf">root window</emphasis> (it's the parent of all
+covering it) is known as the <em>root window</em> (it's the parent of all
 windows, just like the system's root directory is the parent of all 
 subdirectories). Normally, applications don't use the root window, instead
-drawing all of their text inside of windows (<literal remap="tt">newt</literal> doesn't require
+drawing all of their text inside of windows (<tt>newt</tt> doesn't require
 this though -- widgets may be placed directly on the root window without
 difficulty). It is often desirable to display some text, such as a
 program's name or copyright information, on the root window, however.
-<literal remap="tt">Newt</literal> provides two ways of displaying text on the root window. These
-functions may be called at any time. They are the only <literal remap="tt">newt</literal> functions
+<tt>Newt</tt> provides two ways of displaying text on the root window. These
+functions may be called at any time. They are the only <tt>newt</tt> functions
 which are meant to write outside of the current window.
 
-
-<screen>
+<code>
 void newtDrawRootText(int left, int top, const char * text);
-</screen></para>
-
-
+</code></p>
 
-<para>
-This function is straightforward. It displays the string <literal remap="tt">text</literal> at
-the position indicated. If either the <literal remap="tt">left</literal> or <literal remap="tt">top</literal> is
+<p>
+This function is straightforward. It displays the string <tt>text</tt> at
+the position indicated. If either the <tt>left</tt> or <tt>top</tt> is
 negative, the position is measured from the opposite side of the
 screen. The final measurement will seem to be off by one though. For
-example, a <literal remap="tt">top</literal> of -1 indicates the last line on the screen, and
+example, a <tt>top</tt> of -1 indicates the last line on the screen, and
 one of -2 is the line above that.
 
 As it's common to use the last line on the screen to display help information,
-<literal remap="tt">newt</literal> includes special support for doing exactly that. The last
-line on the display is known as the <emphasis remap="bf">help line</emphasis>, and is treated as a
+<tt>newt</tt> includes special support for doing exactly that. The last
+line on the display is known as the <em>help line</em>, and is treated as a
 stack. As the value of the help line normally relates to the window
 currently displayed, using the same structure for window order and the
 help line is very natural. Two functions are provided to manipulate the
 help line.
 
-
-<screen>
+<code>
 void newtPushHelpLine(const char * text);
 void newtPopHelpLine(void);
-</screen>
-
+</code>
 
-The first function, <literal remap="tt">newtPushHelpLine()</literal>, saves the current help line
+The first function, <tt>newtPushHelpLine()</tt>, saves the current help line
 on a stack (which is independent of the window stack) and displays the
-new line. If <literal remap="tt">text</literal> is <literal remap="tt">NULL</literal>, <literal remap="tt">newt</literal>'s default help line is
-displayed (which provides basic instructions on using <literal remap="tt">newt</literal>). If
-<literal remap="tt">text</literal> is a string of length 0, the help line is cleared. For all
-other values of <literal remap="tt">text</literal>, the passed string is displayed at the bottom,
+new line. If <tt>text</tt> is <tt>NULL</tt>, <tt>newt</tt>'s default help line is
+displayed (which provides basic instructions on using <tt>newt</tt>). If
+<tt>text</tt> is a string of length 0, the help line is cleared. For all
+other values of <tt>text</tt>, the passed string is displayed at the bottom,
 left-hand corner of the display. The space between the end of the displayed
 string the the right-hand edge of the terminal is cleared.
 
-<literal remap="tt">newtPopHelpLine()</literal> replaces the current help line with the one it
+<tt>newtPopHelpLine()</tt> replaces the current help line with the one it
 replaced. It's important not to call tt/newtPopHelpLine()/ more then
-<literal remap="tt">newtPushHelpLine()</literal>!
+<tt>newtPushHelpLine()</tt>!
 
-<literal remap="tt">Suspending Newt Applications</literal>
+<tt>Suspending Newt Applications</tt>
 
-By default, <literal remap="tt">newt</literal> programs cannot be suspended by the user (compare
+By default, <tt>newt</tt> programs cannot be suspended by the user (compare
 this to most Unix programs which can be suspended by pressing the suspend
-key (normally <literal remap="tt">^Z</literal>).  Instead, programs can specify a <emphasis remap="bf">callback</emphasis>
+key (normally <tt>^Z</tt>).  Instead, programs can specify a <em>callback</em>
 function which gets invoked when the user presses the suspend key. 
 
-
-<screen>
+<code>
 typedef void (*newtSuspendCallback)(void);
 
 void newtSetSuspendCallback(newtSuspendCallback cb);
-</screen>
-
+</code>
 
 The suspend function neither expects nor returns any value, and can
 do whatever it likes to when it is invoked. If no suspend callback
 is registered, the suspend keystroke is ignored.
 
 If the application should suspend and continue like most user applications,
-the suspend callback needs two other <literal remap="tt">newt</literal> functions.
-
+the suspend callback needs two other <tt>newt</tt> functions.
 
-<screen>
+<code>
 void newtSuspend(void);
 void newtResume(void);
-</screen>
-
+</code>
 
-<literal remap="tt">newtSuspend()</literal> tells <literal remap="tt">newt</literal> to return the terminal to its initial
+<tt>newtSuspend()</tt> tells <tt>newt</tt> to return the terminal to its initial
 state. Once this is done, the application can suspend itself (by
-sending itself a <literal remap="tt">SIGTSTP</literal>, fork a child program, or do whatever
-else it likes. When it wants to resume using the <literal remap="tt">newt</literal> interface,
-it must call <literal remap="tt">newtResume</literal> before doing so. 
+sending itself a <tt>SIGTSTP</tt>, fork a child program, or do whatever
+else it likes. When it wants to resume using the <tt>newt</tt> interface,
+it must call <tt>newtResume</tt> before doing so. 
 
-Note that suspend callbacks are not signal handlers. When <literal remap="tt">newtInit()</literal>
+Note that suspend callbacks are not signal handlers. When <tt>newtInit()</tt>
 takes over the terminal, it disables the part of the terminal interface
-which sends the suspend signal. Instead, if <literal remap="tt">newt</literal> sees the suspend
+which sends the suspend signal. Instead, if <tt>newt</tt> sees the suspend
 keystroke during normal input processing, it immediately calls the suspend
 callback if one has been set. This means that suspending newt applications
-is not asynchronous.</para></sect2>
-
+is not asynchronous.</p></sect1>
 
-<sect2><title>Refreshing the Screen</title>
+<sect1><heading>Refreshing the Screen</heading>
 
-<para>
+<p>
 To increase performance, S-Lang only updates the display when it needs
 to, not when the program tells S-Lang to write to the terminal. ``When it
 needs to'' is implemented as ``right before the we wait for the user to
@@ -386,55 +349,46 @@
 the time, this optimization makes things difficult for programs which
 want to display progress messages without forcing the user to input 
 characters. Applications can force S-Lang to immediately update modified
-portions of the screen by calling <literal remap="tt">newtRefresh</literal>.
-
-
-<orderedlist>
-<listitem>
+portions of the screen by calling <tt>newtRefresh</tt>.
 
-<para>
+<list>
+<item>
+<p>
 The program wants to display a progress message, without forcing
-for the user to enter any characters.</para></listitem>
-<listitem>
-
-<para>
+for the user to enter any characters.</p></item>
+<item>
+<p>
 A misfeature of the program causes part of the screen to be
 corrupted. Ideally, the program would be fixed, but that may not 
 always be practical.
-</para>
-</listitem></orderedlist>
-</para></sect2>
-
-
+</p>
+</item></list>
+</p></sect1>
 
-<sect2><title>Other Miscellaneous Functions</title>
+<sect1><heading>Other Miscellaneous Functions</heading>
 
-<para>
-As always, some function defy characterization. Two of <literal remap="tt">newt</literal>'s general
+<p>
+As always, some function defy characterization. Two of <tt>newt</tt>'s general
 function fit this oddball category.
 
-
-<screen>
+<code>
 void newtBell(void);
 void newtGetScreenSize(int * cols, int * rows);
-</screen>
-
+</code>
 
 The first sends a beep to the terminal. Depending on the terminal's
 settings, this been may or may not be audible. The second function,
-<literal remap="tt">newtGetScreenSize()</literal>, fills in the passed pointers with the
-current size of the terminal.</para></sect2>
-
+<tt>newtGetScreenSize()</tt>, fills in the passed pointers with the
+current size of the terminal.</p></sect1>
 
-<sect2><title>Basic <literal remap="tt">newt</literal> Example</title>
+<sect1><heading>Basic <tt>newt</tt> Example</heading>
 
-<para>
+<p>
 To help illustrate the functions presented in this section here is a short
-sample <literal remap="tt">newt</literal> program which uses many of them. While it doesn't do
-anything interesting, it does show the basic structure of <literal remap="tt">newt</literal> programs.
-
+sample <tt>newt</tt> program which uses many of them. While it doesn't do
+anything interesting, it does show the basic structure of <tt>newt</tt> programs.
 
-<screen>
+<code>
 #include &#60;newt.h&#62;
 #include &#60;stdlib.h&#62;
 
@@ -459,80 +413,72 @@
 
     newtFinished();
 }
-</screen></para></sect2></sect1>
-
+</code></p></sect1></sect>
 
 
-<sect1><title>Windows</title>
+<sect><heading>Windows</heading>
 
-<para>
-While most <literal remap="tt">newt</literal> applications do use windows, <literal remap="tt">newt</literal>'s window
+<p>
+While most <tt>newt</tt> applications do use windows, <tt>newt</tt>'s window
 support is actually extremely limited. Windows must be destroyed in the
 opposite of the order they were created, and only the topmost window may be
 active. Corollaries to this are:
 
+<list>
+<item>
 
-<itemizedlist>
-<listitem>
-
-<para>
-The user may not switch between windows.</para></listitem>
-<listitem>
-
-<para>
+<p>
+The user may not switch between windows.</p></item>
+<item>
+<p>
 Only the top window may be destroyed.
-</para>
-</listitem></itemizedlist>
+</p>
+</item></list>
 
 While this is quite a severe limitation, adopting it greatly simplifies
-both writing <literal remap="tt">newt</literal> applications and developing <literal remap="tt">newt</literal> itself, as it
-separates <literal remap="tt">newt</literal> from the world of event-driven programming. However,
-this tradeoff between function and simplicity may make <literal remap="tt">newt</literal>
+both writing <tt>newt</tt> applications and developing <tt>newt</tt> itself, as it
+separates <tt>newt</tt> from the world of event-driven programming. However,
+this tradeoff between function and simplicity may make <tt>newt</tt>
 unsuitable for some tasks.
-</para>
+</p>
 
-<sect2><title>Creating Windows</title>
+<sect1><heading>Creating Windows</heading>
 
-<para>
-There are two main ways of opening <literal remap="tt">newt</literal> windows: with or without
+<p>
+There are two main ways of opening <tt>newt</tt> windows: with or without
 explicit sizings. When grids (which will be introduced later in this
 tutorial) are used, a window may be made to just fit the grid. When
 grids are not used, explicit sizing must be given.
 
-
-<screen>
+<code>
 int newtCenteredWindow(int width, int height, const char * title);
 int newtOpenWindow(int left, int top, int width, int height, 
 		   const char * title);
-</screen>
-
+</code>
 
 The first of these functions open a centered window of the specified
-size. The <literal remap="tt">title</literal> is optional -- if it is <literal remap="tt">NULL</literal>, then no title
-is used. <literal remap="tt">newtOpenWindow*(</literal> is similar, but it requires a specific
-location for the upper left-hand corner of the window.</para></sect2>
-
+size. The <tt>title</tt> is optional -- if it is <tt>NULL</tt>, then no title
+is used. <tt>newtOpenWindow*(</tt> is similar, but it requires a specific
+location for the upper left-hand corner of the window.</p></sect1>
 
-<sect2><title>Destroying Windows</title>
+<sect1><heading>Destroying Windows</heading>
 
-<para>
+<p>
 All windows are destroyed in the same manner, no matter how the windows
 were originally created.
 
-
-<screen>
+<code>
 void newtPopWindow(void);
-</screen>
-
+</code>
 
 This function removes the top window from the display, and redraws the
-display areas which the window overwrote.</para></sect2></sect1> 
+display areas which the window overwrote.</p></sect1></sect> 
 
 
-<sect1><title>Components</title>
+<sect><heading>Components</heading>
 
-<para>
-Components are the basic user interface element <literal remap="tt">newt</literal> provides. A
+<p>
+Components are the basic user interface element <tt>newt</tt> provides. A
 single component may be (for example) a listbox, push button checkbox,
 a collection of other components. Most components are used to display
 information in a window, provide a place for the user to enter data, or a
@@ -549,8 +495,8 @@
 invoked it. The application may then read the information the user provided
 and continue appropriately.
 
-All <literal remap="tt">newt</literal> components are stored in a common data type, a
-<literal remap="tt">newtComponent</literal> (some of the particulars of <literal remap="tt">newtComponent</literal>s have
+All <tt>newt</tt> components are stored in a common data type, a
+<tt>newtComponent</tt> (some of the particulars of <tt>newtComponent</tt>s have
 already been mentioned. While this makes it easy for programmers to pass
 components around, it does force them to make sure they don't pass
 entry boxes to routines expecting push buttons, as the compiler can't
@@ -560,159 +506,140 @@
 complete, this introduction is enough to let us illustrate the rest of
 the components with some sample code. We'll then discuss the remainder of
 the components, and end this section with a more exhaustive description of
-forms.</para>
-
+forms.</p>
 
-<sect2><title>Introduction to Forms</title>
+<sect1><heading>Introduction to Forms</heading>
 
-<para>
+<p>
 As we've mentioned, forms are simply collections of components. As only one
 form can be active (or running) at a time, every component which the user
 should be able to access must be on the running form (or on a subform of
 the running form). A form is itself a component, which means forms are
-stored in <literal remap="tt">newtComponent</literal> data structures.
-
+stored in <tt>newtComponent</tt> data structures.
 
-<screen>
+<code>
 newtComponent newtForm(newtComponent vertBar, const char * help, int flags);
-</screen>
-
+</code>
 
-To create a form, call <literal remap="tt">newtForm()</literal>. The first parameter is a vertical
+To create a form, call <tt>newtForm()</tt>. The first parameter is a vertical
 scrollbar which should be associated with the form. For now, that should
-always be <literal remap="tt">NULL</literal> (we'll discuss how to create scrolling forms later in
-this section). The second parameter, <literal remap="tt">help</literal>, is currently unused and
-should always be <literal remap="tt">NULL</literal>. The <literal remap="tt">flags</literal> is normally 0, and other values
+always be <tt>NULL</tt> (we'll discuss how to create scrolling forms later in
+this section). The second parameter, <tt>help</tt>, is currently unused and
+should always be <tt>NULL</tt>. The <tt>flags</tt> is normally 0, and other values
 it can take will be discussed later. Now that we've waved away the
 complexity of this function, creating a form boils down to simply:
 
-
-<screen>
+<code>
 newtComponent myForm;
 
 myForm = newtForm(NULL, NULL, 0);
-</screen>
-
+</code>
 
 After a form is created, components need to be added to it --- after all,
 an empty form isn't terribly useful. There are two functions which add
 components to a form.
 
-
-<screen>
+<code>
 void newtFormAddComponent(newtComponent form, newtComponent co);
 void newtFormAddComponents(newtComponent form, ...);
-</screen>
-
+</code>
 
-The first function, <literal remap="tt">newtFormAddComponent()</literal>, adds a single component
+The first function, <tt>newtFormAddComponent()</tt>, adds a single component
 to the form which is passed as the first parameter. The second function
 is simply a convenience function. After passing the form to
-<literal remap="tt">newtFormAddComponents()</literal>, an arbitrary number of components is then
-passed, followed by <literal remap="tt">NULL</literal>. Every component passed is added to the form.
+<tt>newtFormAddComponents()</tt>, an arbitrary number of components is then
+passed, followed by <tt>NULL</tt>. Every component passed is added to the form.
 
 Once a form has been created and components have been added to it, it's
 time to run the form.
 
-
-<screen>
+<code>
 newtComponent newtRunForm(newtComponent form);
-</screen>
-
+</code>
 
 This function runs the form passed to it, and returns the component which
 caused the form to stop running. For now, we'll ignore the return value
 completely.
 
-Notice that this function doesn't fit in with <literal remap="tt">newt</literal>'s normal
+Notice that this function doesn't fit in with <tt>newt</tt>'s normal
 naming convention. It is an older interface which will not work for all
-forms. It was left in <literal remap="tt">newt</literal> only for legacy applications. It is a
-simpler interface than the new <literal remap="tt">newtFormRun()</literal> though, and is still used
+forms. It was left in <tt>newt</tt> only for legacy applications. It is a
+simpler interface than the new <tt>newtFormRun()</tt> though, and is still used
 quite often as a result.
 
 When an application is done with a form, it destroys the form and
 all of the components the form contains.
 
-
-<screen>
+<code>
 void newtFormDestroy(newtComponent form);	
-</screen>
-
+</code>
 
 This function frees the memory resources used by the form and all of the
 components which have been added to the form (including those components
 which are on subforms). Once a form has been destroyed, none of the form's
-components can be used.</para></sect2>
-
+components can be used.</p></sect1>
 
-<sect2><title>Components</title>
+<sect1><heading>Components</heading>
 
-<para>
+<p>
 Non-form components are the most important user-interface component for
-users. They determine how users interact with <literal remap="tt">newt</literal> and how information
-is presented to them.</para></sect2>
+users. They determine how users interact with <tt>newt</tt> and how information
+is presented to them.</p></sect1>
 
 
-<sect2><title>General Component Manipulation</title>
+<sect1><heading>General Component Manipulation</heading>
 
-<para>
+<p>
 There are a couple of functions which work on more then one type of
 components. The description of each component indicates which (if any)
 of these functions are valid for that particular component.
 
-
-<screen>
+<code>
 typedef void (*newtCallback)(newtComponent, void *);
 
 void newtComponentAddCallback(newtComponent co, newtCallback f, void * data);
 void newtComponentTakesFocus(newtComponent co, int val);
-</screen>
-
+</code>
 
 The first registers a callback function for that component. A callback
-function is a function the application provides which <literal remap="tt">newt</literal> calls for a
+function is a function the application provides which <tt>newt</tt> calls for a
 particular component. Exactly when (if ever) the callback is invoked
 depends on the type of component the callback is attached to, and will be
 discussed for the components which support callbacks.
 
-<literal remap="tt">newtComponentTakesFocus()</literal> works on all components. It allows the
+<tt>newtComponentTakesFocus()</tt> works on all components. It allows the
 application to change which components the user is allowed to select as the
 current component, and hence provide input to. Components which do not
 take focus are skipped over during form traversal, but they are displayed
 on the terminal. Some components should never be set to take focus, such
-as those which display static text.</para></sect2>
-
+as those which display static text.</p></sect1>
 
-<sect2><title>Buttons</title>
+<sect1><heading>Buttons</heading>
 
-<para>
-Nearly all forms contain at least one button. <literal remap="tt">Newt</literal> buttons come in two
+<p>
+Nearly all forms contain at least one button. <tt>Newt</tt> buttons come in two
 flavors, full buttons and compact buttons. Full buttons take up quit a bit
 of screen space, but look much better then the single-row compact buttons.
 Other then their size, both button styles behave identically. Different
 functions are used to create the two types of buttons.
 
-
-<screen>
+<code>
 newtComponent newtButton(int left, int top, const char * text);
 newtComponent newtCompactButton(int left, int top, const char * text);
-</screen>
-
+</code>
 
 Both functions take identical parameters. The first two parameters are the
 location of the upper left corner of the button, and the final parameter is
 the text which should be displayed in the button (such as ``Ok'' or
-``Cancel'').</para>
-
+``Cancel'').</p>
 
-<sect3><title>Button Example</title>
+<sect2><heading>Button Example</heading>
 
-<para>
+<p>
 Here is a simple example of both full and compact buttons. It also
 illustrates opening and closing windows, as well a simple form.
 
-
-<screen>
+<code>
 #include &#60;newt.h&#62;
 #include &#60;stdlib.h&#62;
 
@@ -733,40 +660,34 @@
     newtFormDestroy(form);
     newtFinished();
 }
-</screen></para></sect3></sect2>
-
-
+</code></p></sect2></sect1>
 
-<sect2><title>Labels</title>
+<sect1><heading>Labels</heading>
 
-<para>
-Labels are <literal remap="tt">newt</literal>'s simplest component. They display some given text and
+<p>
+Labels are <tt>newt</tt>'s simplest component. They display some given text and
 don't allow any user input.
 
-
-<screen>
+<code>
 newtComponent newtLabel(int left, int top, const char * text);
 void newtLabelSetText(newtComponent co, const char * text);
-</screen>
-
+</code>
 
 Creating a label is just like creating a button; just pass the location of
 the label and the text it should display. Unlike buttons, labels do let the
-application change the text in the label with <literal remap="tt">newtLabelSetText</literal>. When
+application change the text in the label with <tt>newtLabelSetText</tt>. When
 the label's text is changed, the label automatically redraws itself. It
 does not clear out any old text which may be leftover from the previous
 time is was displayed, however, so be sure that the new text is at least
-as long as the old text.</para></sect2>
-
+as long as the old text.</p></sect1>
 
-<sect2><title>Entry Boxes</title>
+<sect1><heading>Entry Boxes</heading>
 
-<para>
+<p>
 Entry boxes allow the user to enter a text string into the form which the
 application can later retrieve.
 
-
-<screen>
+<code>
 typedef int (*newtEntryFilter)(newtComponent entry, void * data, int ch,
 			       int cursor);
 
@@ -775,63 +696,49 @@
 void newtEntrySet(newtComponent co, const char * value, int cursorAtEnd);
 char * newtEntryGetValue(newtComponent co);
 void newtEntrySetFilter(newtComponent co, newtEntryFilter filter, void * data);
-</screen></para>
-
-
+</code></p>
 
-<para>
-<literal remap="tt">newtEntry()</literal> creates a new entry box. After the location of the entry
-box, the initial value for the entry box is passed, which may be <literal remap="tt">NULL</literal>
+<p>
+<tt>newtEntry()</tt> creates a new entry box. After the location of the entry
+box, the initial value for the entry box is passed, which may be <tt>NULL</tt>
 if the box should start off empty. Next, the width of the physical box is
 given. This width may or may not limit the length of the string the user is
-allowed to enter; that depends on the <literal remap="tt">flags</literal>. The <literal remap="tt">resultPtr</literal> must
-be the address of a <literal remap="tt">char *</literal>. Until the entry box is destroyed by
-<literal remap="tt">newtFormDestroy()</literal>, that <literal remap="tt">char *</literal> will point to the current value
+allowed to enter; that depends on the <tt>flags</tt>. The <tt>resultPtr</tt> must
+be the address of a <tt>char *</tt>. Until the entry box is destroyed by
+<tt>newtFormDestroy()</tt>, that <tt>char *</tt> will point to the current value
 of the entry box. It's important that applications make a copy of that
 value before destroying the form if they need to use it later. The
-<literal remap="tt">resultPtr</literal> may be <literal remap="tt">NULL</literal>, in which case the user must use the
-<literal remap="tt">newtEntryGetValue()</literal> function to get the value of the entry box.
+<tt>resultPtr</tt> may be <tt>NULL</tt>, in which case the user must use the
+<tt>newtEntryGetValue()</tt> function to get the value of the entry box.
 
 Entry boxes support a number of flags:
 
-<variablelist>
-
-<varlistentry>
-<term>NEWT_ENTRY_SCROLL</term>
-<listitem>
-<para>If this flag is not specified, the user cannot
+<descrip>
+<tag>NEWT_ENTRY_SCROLL</tag>
+<p>If this flag is not specified, the user cannot
 enter text into the entry box which is wider then the entry box itself.
 This flag removes this limitation, and lets the user enter data of an
-arbitrary length.</para></listitem>
-</varlistentry>
-<varlistentry>
-<term>NEWT_FLAG_HIDDEN</term>
-<listitem>
-<para>If this flag is specified, the value of the entry box
+arbitrary length.</p>
+<tag>NEWT_FLAG_HIDDEN</tag>
+<p>If this flag is specified, the value of the entry box
 is not displayed. This is useful when the application needs to read a
-password, for example.</para></listitem>
-</varlistentry>
-<varlistentry>
-<term>NEWT_FLAG_RETURNEXIT</term>
-<listitem>
-<para>When this flag is given, the entry box will cause
+password, for example.</p>
+<tag>NEWT_FLAG_RETURNEXIT</tag>
+<p>When this flag is given, the entry box will cause
 the form to stop running if the user pressed return inside of the entry
-box. This can provide a nice shortcut for users.</para>
-</listitem>
-</varlistentry>
-</variablelist>
-
+box. This can provide a nice shortcut for users.</p>
+</descrip>
 
 After an entry box has been created, its contents can be set by
-<literal remap="tt">newtEntrySet()</literal>. After the entry box itself, the new string to place
-in the entry box is passed. The final parameter, <literal remap="tt">cursorAtEnd</literal>, controls
+<tt>newtEntrySet()</tt>. After the entry box itself, the new string to place
+in the entry box is passed. The final parameter, <tt>cursorAtEnd</tt>, controls
 where the cursor will appear in the entry box. If it is zero, the cursor
 remains at its present location; a nonzero value moves the cursor to the
 end of the entry box's new value.
 
 While the simplest way to find the value of an entry box is by using a
-<literal remap="tt">resultPtr</literal>, doing so complicates some applications.
-<literal remap="tt">newtEntryGetValue()</literal> returns a pointer to the string which the entry
+<tt>resultPtr</tt>, doing so complicates some applications.
+<tt>newtEntryGetValue()</tt> returns a pointer to the string which the entry
 box currently contains. The returned pointer may not be valid once the
 user further modifies the entry box, and will not be valid after the 
 entry box has been destroyed, so be sure to save its value in a more
@@ -843,38 +750,33 @@
 to the user (such as automatically adding a '.' after the user has typed in
 the first three numbers in an IP address). 
 
-When a filter is registered through <literal remap="tt">newtEntrySetFilter()</literal>, both the
-filter itself and an arbitrary <literal remap="tt">void *</literal>, which passed to the filter
+When a filter is registered through <tt>newtEntrySetFilter()</tt>, both the
+filter itself and an arbitrary <tt>void *</tt>, which passed to the filter
 whenever it is invoked, are recorded. This data pointer isn't used for any
-other purpose, and may be <literal remap="tt">NULL</literal>. Entry filters take four arguments.
-
-
-<orderedlist>
-<listitem>
-
-<para>
-The entry box which had data entered into it</para></listitem>
-<listitem>
-
-<para>
-The data pointer which was registered along with the filter</para></listitem>
-<listitem>
-
-<para>
-The new character which <literal remap="tt">newt</literal> is considering inserting into the
-entry box</para></listitem>
-<listitem>
+other purpose, and may be <tt>NULL</tt>. Entry filters take four arguments.
 
-<para>
+<enum>
+<item>
+<p>
+The entry box which had data entered into it</p></item>
+<item>
+<p>
+The data pointer which was registered along with the filter</p></item>
+<item>
+<p>
+The new character which <tt>newt</tt> is considering inserting into the
+entry box</p></item>
+<item>
+<p>
 The current cursor position (0 is the leftmost position)
-</para>
-</listitem>
-</orderedlist>
+</p>
+</item>
+</enum>
 
 The filter returns 0 if the character should be ignored, or the value of
 the character which should be inserted into the entry box. Filter functions
 which want to do complex manipulations of the string should use
-<literal remap="tt">newtEntrySet()</literal> to update the entry box and then return 0 to prevent
+<tt>newtEntrySet()</tt> to update the entry box and then return 0 to prevent
 the new character from being inserted.
 
 When a callback is attached to a entry box, the callback is invoked
@@ -883,8 +785,7 @@
 Here is a sample program which illustrates the use of both labels and
 entry boxes.
 
-
-<screen>
+<code>
 #include &#60;newt.h&#62;
 #include &#60;stdlib.h&#62;
 #include &#60;stdio.h&#62;
@@ -915,18 +816,16 @@
        from the entry widget. */
     newtFormDestroy(form);
 }
-</screen></para></sect2>
-
-
+</code></p></sect1>
 
-<sect2><title>Checkboxes</title>
+<sect1><heading>Checkboxes</heading>
 
-<para>
+<p>
 Most widget sets include checkboxes which toggle between two value (checked
-or not checked). <literal remap="tt">Newt</literal> checkboxes are more flexible. When the user
+or not checked). <tt>Newt</tt> checkboxes are more flexible. When the user
 presses the space bar on a checkbox, the checkbox's value changes to the
 next value in an arbitrary sequence (which wraps). Most checkboxes have
-two items in that sequence, checked or not, but <literal remap="tt">newt</literal> allows an
+two items in that sequence, checked or not, but <tt>newt</tt> allows an
 arbitrary number of value. This is useful when the user must pick from a
 limited number of choices.
 
@@ -934,72 +833,64 @@
 represented as a string. The checkbox components displays the character
 which currently represents its value the left of a text label, and returns
 the same character as its current value. The default sequence for
-checkboxes is <literal remap="tt">" *"</literal>, with <literal remap="tt">' '</literal> indicating false and <literal remap="tt">'*'</literal> true.
-
+checkboxes is <tt>" *"</tt>, with <tt>' '</tt> indicating false and <tt>'*'</tt> true.
 
-<screen>
+<code>
 newtComponent newtCheckbox(int left, int top, const char * text, char defValue,
 			   const char * seq, char * result);
 char newtCheckboxGetValue(newtComponent co);
-</screen></para>
-
-
+</code></p>
 
-<para>
+<p>
 Like most components, the position of the checkbox is the first thing
-passed to the function that creates one. The next parameter, <literal remap="tt">text</literal>, is
+passed to the function that creates one. The next parameter, <tt>text</tt>, is
 the text which is displayed to the right of the area which is checked.  The
-<literal remap="tt">defValue</literal> is the initial value for the checkbox, and <literal remap="tt">seq</literal> is the
-sequence which the checkbox should go through (<literal remap="tt">defValue</literal> must be
-in <literal remap="tt">seq</literal>. <literal remap="tt">seq</literal> may be <literal remap="tt">NULL</literal>, in which case <literal remap="tt">" *"</literal> is used.
-The final parameter, <literal remap="tt">result</literal>, should point to a character which the
-checkbox should always record its current value in. If <literal remap="tt">result</literal> is
-<literal remap="tt">NULL</literal>, <literal remap="tt">newtCheckboxGetValue()</literal> must be used to get the current
+<tt>defValue</tt> is the initial value for the checkbox, and <tt>seq</tt> is the
+sequence which the checkbox should go through (<tt>defValue</tt> must be
+in <tt>seq</tt>. <tt>seq</tt> may be <tt>NULL</tt>, in which case <tt>" *"</tt> is used.
+The final parameter, <tt>result</tt>, should point to a character which the
+checkbox should always record its current value in. If <tt>result</tt> is
+<tt>NULL</tt>, <tt>newtCheckboxGetValue()</tt> must be used to get the current
 value of the checkbox.
 
-<literal remap="tt">newtCheckboxGetValue()</literal> is straightforward, returning the character
+<tt>newtCheckboxGetValue()</tt> is straightforward, returning the character
 in the sequence which indicates the current value of the checkbox
 
 If a callback is attached to a checkbox, the callback is invoked whenever
 the checkbox responds to a user's keystroke. The entry box may respond by
-taking focus or giving up focus, as well as by changing its current value.</para></sect2>
-
+taking focus or giving up focus, as well as by changing its current value.</p></sect1>
 
-<sect2><title>Radio Buttons</title>
+<sect1><heading>Radio Buttons</heading>
 
-<para>
+<p>
 Radio buttons look very similar to checkboxes. The key difference between
 the two is that radio buttons are grouped into sets, and exactly one radio
 button in that set may be turned on. If another radio button is selected,
 the button which was selected is automatically deselected.
 
-
-
-<screen>
+<code>
 newtComponent newtRadiobutton(int left, int top, const char * text, 
 			      int isDefault, newtComponent prevButton);
 newtComponent newtRadioGetCurrent(newtComponent setMember);
-</screen>
-
+</code>
 
-Each radio button is created by calling <literal remap="tt">newtRadiobutton()</literal>. After
+Each radio button is created by calling <tt>newtRadiobutton()</tt>. After
 the position of the radio button, the text displayed with the button
-is passed. <literal remap="tt">isDefault</literal> should be nonzero if the radio button is to
-be turned on by default. The final parameter, <literal remap="tt">prevMember</literal> is used
-to group radio buttons into sets. If <literal remap="tt">prevMember</literal> is <literal remap="tt">NULL</literal>, the 
+is passed. <tt>isDefault</tt> should be nonzero if the radio button is to
+be turned on by default. The final parameter, <tt>prevMember</tt> is used
+to group radio buttons into sets. If <tt>prevMember</tt> is <tt>NULL</tt>, the 
 radio button is assigned to a new set. If the radio button should belong
-to a preexisting set, <literal remap="tt">prevMember</literal> must be the previous radio button
+to a preexisting set, <tt>prevMember</tt> must be the previous radio button
 added to that set.
 
 Discovering which radio button in a set is currently selected necessitates
-<literal remap="tt">newtRadioGetCurrent()</literal>. It may be passed any radio button in the set
+<tt>newtRadioGetCurrent()</tt>. It may be passed any radio button in the set
 you're interested in, and it returns the radio button component currently
 selected.
 
 Here is an example of both checkboxes and radio buttons.
 
-
-<screen>
+<code>
 #include &#60;newt.h&#62;
 #include &#60;stdlib.h&#62;
 #include &#60;stdio.h&#62;
@@ -1042,92 +933,74 @@
     /* But the checkbox's value is stored locally */
     printf("checkbox value: '%c'\n", cbValue);
 }
-</screen></para></sect2>
-
-
+</code></p></sect1>
 
-<sect2><title>Scales</title>
+<sect1><heading>Scales</heading>
 
-<para>
+<p>
 It's common for programs to need to display a progress meter on the
 terminal while it performs some length operation (it behaves like an
 anesthetic). The scale component is a simple way of doing this. It
 displays a horizontal bar graph which the application can update as the
 operation continues.
 
-
-<screen>
+<code>
 newtComponent newtScale(int left, int top, int width, long long fullValue);
 void newtScaleSet(newtComponent co, unsigned long long amount);
-</screen>
-
+</code>
 
-When the scale is created with <literal remap="tt">newtScale</literal>, it is given the width of the
+When the scale is created with <tt>newtScale</tt>, it is given the width of the
 scale itself as well as the value which means that the scale should be
 drawn as full. When the position of the scale is set with
-<literal remap="tt">newtScaleSet()</literal>, the scale is told the amount of the scale which should
-be filled in relative to the <literal remap="tt">fullAmount</literal>. For example, if the
-application is copying a file, <literal remap="tt">fullValue</literal> could be the number of bytes
-in the file, and when the scale is updated <literal remap="tt">newtScaleSet()</literal> would be
-passed the number of bytes which have been copied so far.</para></sect2>
-
+<tt>newtScaleSet()</tt>, the scale is told the amount of the scale which should
+be filled in relative to the <tt>fullAmount</tt>. For example, if the
+application is copying a file, <tt>fullValue</tt> could be the number of bytes
+in the file, and when the scale is updated <tt>newtScaleSet()</tt> would be
+passed the number of bytes which have been copied so far.</p></sect1>
 
-<sect2><title>Textboxes</title>
+<sect1><heading>Textboxes</heading>
 
-<para>
+<p>
 Textboxes display a block of text on the terminal, and is appropriate for
 display large amounts of text. 
 
-
-<screen>
+<code>
 newtComponent newtTextbox(int left, int top, int width, int height, int flags);
 void newtTextboxSetText(newtComponent co, const char * text);
-</screen>
-
+</code>
 
-<literal remap="tt">newtTextbox()</literal> creates a new textbox, but does not fill it with data.
+<tt>newtTextbox()</tt> creates a new textbox, but does not fill it with data.
 The function is passed the location for the textbox on the screen, the
 width and height of the textbox (in characters), and zero or more of the
 following flags:
 
-<variablelist>
-
-<varlistentry>
-<term>NEWT_FLAG_WRAP</term>
-<listitem>
-<para>All text in the textbox should be wrapped to fit
+<descrip>
+<tag>NEWT_FLAG_WRAP</tag>
+<p>All text in the textbox should be wrapped to fit
 the width of the textbox. If this flag is not specified, each newline
 delimited line in the text is truncated if it is too long to fit.
 
-When <literal remap="tt">newt</literal> wraps text, it tries not to break lines on spaces or tabs.
+When <tt>newt</tt> wraps text, it tries not to break lines on spaces or tabs.
 Literal newline characters are respected, and may be used to force line
-breaks.</para>
-<variablelist>
-
-<varlistentry>
-<term>NEWT_FLAG_SCROLL</term>
-<listitem>
-<para>The text box should be scrollable. When this option
+breaks.</p>
+<tag>NEWT_FLAG_SCROLL</tag>
+<p>The text box should be scrollable. When this option
 is used, the scrollbar which is added increases the width of the area used
 by the textbox by 2 characters; that is the textbox is 2 characters wider
-then the width passed to <literal remap="tt">newtTextbox()</literal>.
-</para></listitem>
-</varlistentry>
-</variablelist>
-
-
+then the width passed to <tt>newtTextbox()</tt>.
+</descrip>
+</p>
 
-<para>
+<p>
 After a textbox has been created, text may be added to it through
-<literal remap="tt">newtTextboxSetText()</literal>, which takes only the textbox and the new text as
+<tt>newtTextboxSetText()</tt>, which takes only the textbox and the new text as
 parameters. If the textbox already contained text, that text is replaced by
 the new text. The textbox makes its own copy of the passed text, so these
-is no need to keep the original around unless it's convenient.</para></listitem></varlistentry></variablelist></para>
-
+is no need to keep the original around unless it's convenient.</p>
 
-<sect3><title>Reflowing Text</title>
+<sect2><heading>Reflowing Text</heading>
 
-<para>
+<p>
 When applications need to display large amounts of text, it's common not to
 know exactly where the linebreaks should go. While textboxes are quite
 willing to scroll the text, the programmer still must know what width the
@@ -1136,52 +1009,48 @@
 especially prevalent in internationalized programs, which need to make a
 wide variety of message string look god on a screen.
 
-To help with this, <literal remap="tt">newt</literal> provides routines to reformat text to look
+To help with this, <tt>newt</tt> provides routines to reformat text to look
 good. It tries different widths to figure out which one will look ``best''
 to the user. As these commons are almost always used to format text for
-textbox components, <literal remap="tt">newt</literal> makes it easy to construct a textbox with
+textbox components, <tt>newt</tt> makes it easy to construct a textbox with
 reflowed text.
 
-
-<screen>
+<code>
 char * newtReflowText(char * text, int width, int flexDown, int flexUp,
 		      int * actualWidth, int * actualHeight);
 newtComponent newtTextboxReflowed(int left, int top, char * text, int width,
 				  int flexDown, int flexUp, int flags);
 int newtTextboxGetNumLines(newtComponent co);
-</screen></para>
-
-
+</code></p>
 
-<para>
-<literal remap="tt">newtReflowText()</literal> reflows the <literal remap="tt">text</literal> to a target width of
-<literal remap="tt">width</literal>. The actual width of the longest line in the returned string is
-between <literal remap="tt">width - flexDown</literal> and <literal remap="tt">width + flexUp</literal>; the actual maximum
+<p>
+<tt>newtReflowText()</tt> reflows the <tt>text</tt> to a target width of
+<tt>width</tt>. The actual width of the longest line in the returned string is
+between <tt>width - flexDown</tt> and <tt>width + flexUp</tt>; the actual maximum
 line length is chosen to make the displayed check look rectangular. 
-The <literal remap="tt">int</literal>s pointed to by <literal remap="tt">actualWidth</literal> and <literal remap="tt">actualHeight</literal> are set
+The <tt>int</tt>s pointed to by <tt>actualWidth</tt> and <tt>actualHeight</tt> are set
 to the width of the longest line and the number of lines in in the
-returned text, respectively. Either one may be <literal remap="tt">NULL</literal>. The return
-value points to the reflowed text, and is allocated through <literal remap="tt">malloc()</literal>.
+returned text, respectively. Either one may be <tt>NULL</tt>. The return
+value points to the reflowed text, and is allocated through <tt>malloc()</tt>.
 
 When the reflowed text is being placed in a textbox it may be easier to use
-<literal remap="tt">newtTextboxReflowed()</literal>, which creates a textbox, reflows the text, and
+<tt>newtTextboxReflowed()</tt>, which creates a textbox, reflows the text, and
 places the reflowed text in the listbox. It's parameters consist of the
 position of the final textbox, the width and flex values for the text
-(which are identical to the parameters passed to <literal remap="tt">newtReflowText()</literal>,
+(which are identical to the parameters passed to <tt>newtReflowText()</tt>,
 and the flags for the textbox (which are the same as the flags for
-<literal remap="tt">newtTextbox()</literal>. This function does not let you limit the height of the
+<tt>newtTextbox()</tt>. This function does not let you limit the height of the
 textbox, however, making limiting it's use to constructing textboxes which
 don't need to scroll.
 
-To find out how tall the textbox created by <literal remap="tt">newtTextboxReflowed()</literal> is, 
-use <literal remap="tt">newtTextboxGetNumLines()</literal>, which returns the number of lines in the
-textbox. For textboxes created by <literal remap="tt">newtTextboxReflowed()</literal>, this is
+To find out how tall the textbox created by <tt>newtTextboxReflowed()</tt> is, 
+use <tt>newtTextboxGetNumLines()</tt>, which returns the number of lines in the
+textbox. For textboxes created by <tt>newtTextboxReflowed()</tt>, this is
 always the same as the height of the textbox.
 
 Here's a simple program which uses a textbox to display a message.
 
-
-<screen>
+<code>
 #include &#60;newt.h&#62;
 #include &#60;stdlib.h&#62;
 
@@ -1211,25 +1080,21 @@
     newtFormDestroy(form);
     newtFinished();
 }
-</screen></para></sect3></sect2>
-
-
+</code></p></sect2></sect1>
 
-<sect2><title>Scrollbars</title>
+<sect1><heading>Scrollbars</heading>
 
-<para>
-Scrollbars (which, currently, are always vertical in <literal remap="tt">newt</literal>), may be
+<p>
+Scrollbars (which, currently, are always vertical in <tt>newt</tt>), may be
 attached to forms to let them contain more data then they have space for.
 While the actual process of making scrolling forms is discussed at the end 
 of this section, we'll go ahead and introduce scrollbars now so you'll be
 ready.
 
-
-<screen>
+<code>
 newtComponent newtVerticalScrollbar(int left, int top, int height,
 				    int normalColorset, int thumbColorset);
-</screen>
-
+</code>
 
 When a scrollbar is created, it is given a position on the screen, a
 height, and two colors. The first color is the color used for drawing the
@@ -1237,34 +1102,33 @@
 only place in newt where an application specifically sets colors for a
 component. It's done here to let the colors a scrollbar use match the
 colors of the component the scrollbar is mated too. When a scrollbar is
-being used with a form, <literal remap="tt">normalColorset</literal> is often
-<literal remap="tt">NEWT_COLORSET_WINDOW</literal> and <literal remap="tt">thumbColorset</literal>
-<literal remap="tt">NEWT_COLORSET_ACTCHECKBOX</literal>. Of course, feel free to peruse
-<literal remap="tt">&lt;newt.h&gt;</literal> and pick your own colors.
+being used with a form, <tt>normalColorset</tt> is often
+<tt>NEWT_COLORSET_WINDOW</tt> and <tt>thumbColorset</tt>
+<tt>NEWT_COLORSET_ACTCHECKBOX</tt>. Of course, feel free to peruse
+<tt>&lt;newt.h&gt;</tt> and pick your own colors.
 
 As the scrollbar is normally updated by the component it is mated with,
-there is no public interface for moving the thumb.</para></sect2>
+there is no public interface for moving the thumb.</p></sect1>
 
+<sect1><heading>Listboxes</heading>
 
-<sect2><title>Listboxes</title>
-<para>
+<p>
 Listboxes are the most complicated components 
-<literal remap="tt">newt</literal> provides. They can
+<tt>newt</tt> provides. They can
 allow a single selection or multiple selection, and are easy to update.
-Unfortunately, their API is also the least consistent of <literal remap="tt">newt</literal>'s
+Unfortunately, their API is also the least consistent of <tt>newt</tt>'s
 components. Each entry in a listbox is a ordered pair of the text which should be
-displayed for that item and a <emphasis remap="bf">key</emphasis>, which is a <literal remap="tt">void *</literal> that
+displayed for that item and a <em>key</em>, which is a <tt>void *</tt> that
 uniquely identifies that listbox item. Many applications pass integers in
 as keys, but using arbitrary pointers makes many applications significantly
-easier to code.</para>
+easier to code.</p>
 
-<sect3><title>Basic Listboxes</title>
+<sect2><heading>Basic Listboxes</heading>
 
-<para>
+<p>
 Let's start off by looking at the most important listbox functions.
 
-
-<screen>
+<code>
 newtComponent newtListbox(int left, int top, int height, int flags);
 int newtListboxAppendEntry(newtComponent co, const char * text, 
 			   const void * data);
@@ -1272,212 +1136,183 @@
 void newtListboxSetWidth(newtComponent co, int width);
 void newtListboxSetCurrent(newtComponent co, int num);
 void newtListboxSetCurrentByKey(newtComponent co, void * key);
-</screen></para>
-
-
+</code></p>
 
-<para>
+<p>
 A listbox is created at a certain position and a given height. The
-<literal remap="tt">height</literal> is used for two things. First of all, it is the minimum
+<tt>height</tt> is used for two things. First of all, it is the minimum
 height the listbox will use. If there are less items in the listbox then
 the height, suggests the listbox will still take up that minimum amount
 of space. Secondly, if the listbox is set to be scrollable (by setting
-the <literal remap="tt">NEWT_FLAG_SCROLL flag</literal>, the <literal remap="tt">height</literal> is also the maximum height
+the <tt>NEWT_FLAG_SCROLL flag</tt>, the <tt>height</tt> is also the maximum height
 of the listbox. If the listbox may not scroll, it increases its height to
 display all of its items.
 
 The following flags may be used when creating a listbox:
 
-<variablelist>
-
-<varlistentry>
-<term>NEWT_FLAG_SCROLL</term>
-<listitem>
-<para>The listbox should scroll to display all of the
-items it contains.</para></listitem>
-</varlistentry>
-<varlistentry>
-<term>NEWT_FLAG_RETURNEXIT</term>
-<listitem>
-<para>When the user presses return on an item in the
-list, the form should return.</para></listitem>
-</varlistentry>
-<varlistentry>
-<term>NEWT_FLAG_BORDER</term>
-<listitem>
-<para>A frame is drawn around the listbox, which can make
+<descrip>
+<tag>NEWT_FLAG_SCROLL</tag>
+<p>The listbox should scroll to display all of the
+items it contains.</p>
+<tag>NEWT_FLAG_RETURNEXIT</tag>
+<p>When the user presses return on an item in the
+list, the form should return.</p>
+<tag>NEWT_FLAG_BORDER</tag>
+<p>A frame is drawn around the listbox, which can make
 it easier to see which listbox has the focus when a form contains multiple
-listboxes.</para></listitem>
-</varlistentry>
-<varlistentry>
-<term>NEWT_FLAG_MULTIPLE</term>
-<listitem>
-<para>By default, a listbox only lets the user select
+listboxes.</p>
+<tag>NEWT_FLAG_MULTIPLE</tag>
+<p>By default, a listbox only lets the user select
 one item in the list at a time. When this flag is specified, they may
-select multiple items from the list.</para></listitem></varlistentry>
-</variablelist></para>
-
+select multiple items from the list.</p>
+</descrip></p>
 
-<para>
+<p>
 Once a listbox has been created, items are added to it by invoking
-<literal remap="tt">newtListboxAppendEntry()</literal>, which adds new items to the end of the list.
-In addition to the listbox component, <literal remap="tt">newtListboxAppendEntry()</literal> needs
+<tt>newtListboxAppendEntry()</tt>, which adds new items to the end of the list.
+In addition to the listbox component, <tt>newtListboxAppendEntry()</tt> needs
 both elements of the (text, key) ordered pair. 
 
-For lists which only allow a single selection, <literal remap="tt">newtListboxGetCurrent()</literal>
+For lists which only allow a single selection, <tt>newtListboxGetCurrent()</tt>
 should be used to find out which listbox item is currently selected. It
 returns the key of the currently selected item.
 
 Normally, a listbox is as wide as its widest element, plus space for a
 scrollbar if the listbox is supposed to have one. To make the listbox
-any larger then that, use <literal remap="tt">newtListboxSetWidth()</literal>, which overrides the
+any larger then that, use <tt>newtListboxSetWidth()</tt>, which overrides the
 natural list of the listbox. Once the width has been set, it's fixed. The
 listbox will no longer grow to accommodate new entries, so bad things may
 happen! 
 
 An application can change the current position of the listbox (where the
-selection bar is displayed) by calling <literal remap="tt">newtListboxSetCurrent()</literal> or
-<literal remap="tt">newtListboxSetCurrentByKey()</literal>. The first sets the current position to the
+selection bar is displayed) by calling <tt>newtListboxSetCurrent()</tt> or
+<tt>newtListboxSetCurrentByKey()</tt>. The first sets the current position to the
 entry number which is passed as the second argument, with 0 indicating
-the first entry. <literal remap="tt">newtListboxSetCurrentByKey()</literal> sets the current position
-to the entry whose <literal remap="tt">key</literal> is passed into the function.</para></sect3>
-
+the first entry. <tt>newtListboxSetCurrentByKey()</tt> sets the current position
+to the entry whose <tt>key</tt> is passed into the function.</p></sect2>
 
-<sect3><title>Manipulating Listbox Contents</title>
+<sect2><heading>Manipulating Listbox Contents</heading>
 
-<para>
+<p>
 While the contents of many listboxes never need to change, some applications
-need to change the contents of listboxes regularly. <literal remap="tt">Newt</literal> includes
+need to change the contents of listboxes regularly. <tt>Newt</tt> includes
 complete support for updating listboxes. These new functions are in
-addition to <literal remap="tt">newtListboxAppendEntry()</literal>, which was already discussed.
-
+addition to <tt>newtListboxAppendEntry()</tt>, which was already discussed.
 
-<screen>
+<code>
 void newtListboxSetEntry(newtComponent co, void * key, const char * text);
 int newtListboxInsertEntry(newtComponent co, const char * text, 
                            const void * data, void * key);
 int newtListboxDeleteEntry(newtComponent co, void * key);
 void newtListboxClear(newtComponent co);
-</screen></para>
-
-
+</code></p>
 
-<para>
-The first of these, <literal remap="tt">newtListboxSetEntry()</literal>, updates the text for a
-key which is already in the listbox. The <literal remap="tt">key</literal> specifies which listbox
-entry should be modified, and <literal remap="tt">text</literal> becomes the new text for that entry
+<p>
+The first of these, <tt>newtListboxSetEntry()</tt>, updates the text for a
+key which is already in the listbox. The <tt>key</tt> specifies which listbox
+entry should be modified, and <tt>text</tt> becomes the new text for that entry
 in the listbox.
 
-<literal remap="tt">newtListboxInsertEntry()</literal> inserts a new listbox entry <emphasis remap="bf">after</emphasis> an
-already existing entry, which is specified by the <literal remap="tt">key</literal> parameter.
-The <literal remap="tt">text</literal> and <literal remap="tt">data</literal> parameters specify the new entry which should
+<tt>newtListboxInsertEntry()</tt> inserts a new listbox entry <em>after</em> an
+already existing entry, which is specified by the <tt>key</tt> parameter.
+The <tt>text</tt> and <tt>data</tt> parameters specify the new entry which should
 be added.
 
 Already-existing entries are removed from a listbox with
-<literal remap="tt">newtListboxDeleteEntry()</literal>. It removes the listbox entry with the
-specified <literal remap="tt">key</literal>. If you want to remove all of the entries from a
-listbox, use <literal remap="tt">newtListboxClear()</literal>.</para></sect3> 
-
+<tt>newtListboxDeleteEntry()</tt>. It removes the listbox entry with the
+specified <tt>key</tt>. If you want to remove all of the entries from a
+listbox, use <tt>newtListboxClear()</tt>.</p></sect2> 
 
-<sect3><title>Multiple Selections</title>
+<sect2><heading>Multiple Selections</heading>
 
-<para>
-When a listbox is created with <literal remap="tt">NEWT_FLAG_MULTIPLE</literal>, the user can select
+<p>
+When a listbox is created with <tt>NEWT_FLAG_MULTIPLE</tt>, the user can select
 multiple items from the list. When this option is used, a different set of
 functions must be used to manipulate the listbox selection.
 
-
-<screen>
+<code>
 void newtListboxClearSelection(newtComponent co);
 void **newtListboxGetSelection(newtComponent co, int *numitems);
 void newtListboxSelectItem(newtComponent co, const void * key,
 	                   enum newtFlagsSense sense);
-</screen>
-
+</code>
 
-The simplest of these is <literal remap="tt">newtListboxClearSelection()</literal>, which deselects
+The simplest of these is <tt>newtListboxClearSelection()</tt>, which deselects
 all of the items in the list (listboxes which allow multiple selections
-also allow zero selections). <literal remap="tt">newtListboxGetSelection()</literal> returns a
+also allow zero selections). <tt>newtListboxGetSelection()</tt> returns a
 pointer to an array which contains the keys for all of the items in the
-listbox currently selected. The <literal remap="tt">int</literal> pointed to by <literal remap="tt">numitems</literal> is
+listbox currently selected. The <tt>int</tt> pointed to by <tt>numitems</tt> is
 set to the number of items currently selected (and hence the number of
 items in the returned array). The returned array is dynamically allocated,
-and must be released through <literal remap="tt">free()</literal>.
-
-<literal remap="tt">newtListboxSelectItem()</literal> lets the program select and deselect specific
-listbox entries. The <literal remap="tt">key</literal> of the listbox entry is being affected is
-passed, and <literal remap="tt">sense</literal> is one of <literal remap="tt">NEWT_FLAGS_RESET</literal>, which deselects
-the entry, <literal remap="tt">NEWT_FLAGS_SET</literal>, which selects the entry, or
-<literal remap="tt">NEWT_FLAGS_TOGGLE</literal>, which reverses the current selection status.</para></sect3></sect2>
-
+and must be released through <tt>free()</tt>.
 
+<tt>newtListboxSelectItem()</tt> lets the program select and deselect specific
+listbox entries. The <tt>key</tt> of the listbox entry is being affected is
+passed, and <tt>sense</tt> is one of <tt>NEWT_FLAGS_RESET</tt>, which deselects
+the entry, <tt>NEWT_FLAGS_SET</tt>, which selects the entry, or
+<tt>NEWT_FLAGS_TOGGLE</tt>, which reverses the current selection status.</p>
+</sect2></sect1>
 
-<sect2><title>Advanced Forms</title>
+<sect1><heading>Advanced Forms</heading>
 
-<para>
+<p>
 Forms, which tie components together, are quite important in the world of
-<literal remap="tt">newt</literal>. While we've already discussed the basics of forms, we've omitted
-many of the details.</para>
-
+<tt>newt</tt>. While we've already discussed the basics of forms, we've omitted
+many of the details.</p>
 
-<sect3><title>Exiting From Forms</title>
+<sect2><heading>Exiting From Forms</heading>
 
-<para>
+<p>
 Forms return control to the application for a number of reasons:
 
-
-<itemizedlist>
-<listitem>
-
-<para>
+<itemize>
+<item>
+<p>
 A component can force the form to exit. Buttons do this whenever they
-are pushed, and other components exit when <literal remap="tt">NEWT_FLAG_RETURNEXIT</literal> has
-been specified.</para></listitem>
-<listitem>
-
-<para>
+are pushed, and other components exit when <tt>NEWT_FLAG_RETURNEXIT</tt> has
+been specified.</p></item>
+<item>
+<p>
 Applications can setup hot keys which cause the form to exit when
-they are pressed.</para></listitem>
-<listitem>
-
-<para>
-<literal remap="tt">Newt</literal> can exit when file descriptors are ready to be read or
+they are pressed.</p></item>
+<item>
+<p>
+<tt>Newt</tt> can exit when file descriptors are ready to be read or
 ready to be written to.
-</para>
-</listitem></itemizedlist>
+</p>
+</item>
+</itemize>
 
-By default, <literal remap="tt">newt</literal> forms exit when the F12 key is pressed (F12 is setup
-as a hot key by default). <literal remap="tt">Newt</literal> applications should treat F12 as an
+<p>
+By default, <tt>newt</tt> forms exit when the F12 key is pressed (F12 is setup
+as a hot key by default). <tt>Newt</tt> applications should treat F12 as an
 ``Ok'' button. If applications don't want F12 to exit the form, they can
-specify <literal remap="tt">NEWT_FLAG_NOF12</literal> as flag when creating the form with 
-<literal remap="tt">newtForm</literal>.
-
+specify <tt>NEWT_FLAG_NOF12</tt> as flag when creating the form with 
+<tt>newtForm</tt>.
 
-<screen>
+<code>
 void newtFormAddHotKey(newtComponent co, int key);
 void newtFormWatchFd(newtComponent form, int fd, int fdFlags);
-</screen>
-
-
+</code>
 
-<screen>
+<code>
 void newtDrawForm(newtComponent form);
 newtComponent newtFormGetCurrent(newtComponent co);
 void newtFormSetCurrent(newtComponent co, newtComponent subco);
 void newtFormRun(newtComponent co, struct newtExitStruct * es);
-</screen>
-
-
+</code>
 
-<screen>
+<code>
 newtComponent newtForm(newtComponent vertBar, const char * help, int flags);
 void newtFormSetBackground(newtComponent co, int color);
 void newtFormSetHeight(newtComponent co, int height);
 void newtFormSetWidth(newtComponent co, int width);
-</screen>
-</para>
-</sect3>
+</code>
+</p>
+
 </sect2>
 </sect1>
+</sect>
+
 </article>
 
# See https://gitweb.gentoo.org/repo/gentoo.git/tree/dev-libs/newt/files/newt-0.52.14-tcl.patch
diff -urNad newt-0.52.18-orig/whiptcl.c newt-0.52.18/whiptcl.c
--- newt-0.52.18-orig/whiptcl.c	2014-10-23 11:34:37.000000000 +0300
+++ newt-0.52.18/whiptcl.c	2016-10-31 14:58:28.000000000 +0200
@@ -137,45 +137,45 @@
     
     if (arg < -1) {
 	/* this could buffer oveflow, bug we're not setuid so I don't care */
-	interp->result = malloc(200);
-	interp->freeProc = TCL_DYNAMIC;
-	sprintf(interp->result, "%s: %s\n", 
+	char *tmp = malloc(200);
+	sprintf(tmp, "%s: %s\n", 
 		poptBadOption(optCon, POPT_BADOPTION_NOALIAS), 
 		poptStrerror(arg));
+	Tcl_SetResult(interp, tmp, TCL_DYNAMIC);
 
 	return TCL_ERROR;
     }
 
     if (mode == MODE_NONE) {
-	interp->result = "no dialog mode was specified";
+    	Tcl_SetResultString(interp, "no dialog mode was specified");
 	return TCL_ERROR;
     } else if (rc) {
-	interp->result = "multiple modes were specified";
+	Tcl_SetResultString(interp, "multiple modes were specified");
 	return TCL_ERROR;
     }
 
     if (!(text = poptGetArg(optCon))) {
-	interp->result = "missing text parameter";
+	Tcl_SetResultString(interp, "missing text parameter");
 	return TCL_ERROR;
     }
 
     if (!(nextArg = poptGetArg(optCon))) {
-	interp->result = "height missing";
+	Tcl_SetResultString(interp, "height missing");
 	return TCL_ERROR;
     }
     height = strtoul(nextArg, &end, 10);
     if (*end) {
-	interp->result = "height is not a number";
+	Tcl_SetResultString(interp, "height is not a number");
 	return TCL_ERROR;
     }
 
     if (!(nextArg = poptGetArg(optCon))) {
-	interp->result = "width missing";
+	Tcl_SetResultString(interp, "width missing");
 	return TCL_ERROR;
     }
     width = strtoul(nextArg, &end, 10);
     if (*end) {
-	interp->result = "width is not a number";
+	Tcl_SetResultString(interp, "width is not a number");
 	return TCL_ERROR;
     }
 
@@ -196,33 +196,30 @@
       case MODE_YESNO:
 	rc = messageBox(text, height, width, MSGBOX_YESNO, flags);
 	if (rc == DLG_OKAY)
-	    interp->result = "yes";
+	    Tcl_SetResultString(interp, "yes");
 	else 
-	    interp->result = "no";
+	    Tcl_SetResultString(interp, "no");
 	if (rc == DLG_ERROR) rc = 0;
 	break;
 
       case MODE_INPUTBOX:
 	rc = inputBox(text, height, width, optCon, flags, &result);
 	if (rc ==DLG_OKAY) {
-	    interp->result = result;
-	    interp->freeProc = TCL_DYNAMIC;
+	    Tcl_SetResult(interp, result, TCL_DYNAMIC);
 	}
 	break;
 
       case MODE_MENU:
 	rc = listBox(text, height, width, optCon, flags, default_item, &result);
 	if (rc==DLG_OKAY) {
-	    interp->result = result;
-	    interp->freeProc = TCL_DYNAMIC;
+	    Tcl_SetResult(interp, result, TCL_DYNAMIC);
 	}
 	break;
 
       case MODE_RADIOLIST:
 	rc = checkList(text, height, width, optCon, 1, flags, &selections);
 	if (rc==DLG_OKAY) {
-	    interp->result = selections[0];
-	    interp->freeProc = TCL_DYNAMIC;
+	    Tcl_SetResult(interp, selections[0], TCL_DYNAMIC);
 
 	    free(selections);
 	}
@@ -247,7 +244,7 @@
     newtPopWindow();
 
     if (rc == DLG_ERROR) {
-	interp->result = "bad paramter for whiptcl dialog box";
+	Tcl_SetResultString(interp, "bad paramter for whiptcl dialog box");
 	return TCL_ERROR;
     } 
 
